
<html>
<head>
  <title>QuArK's Model Structure</title>
  <meta name="Description" content="QuArK Information Database - Page: 1.5.1.&nbsp;QuArK's Model Structure">
  <meta name="Keywords" content="QuArK InfoBase Quake Army Knife QRK QKM Python PY Map Editor Hexen Heretic Half-Life Sin Kingpin Soldier-of-Fortune Star-Trek-Voyager Elite-Force">
</head>

<link rel=stylesheet href="standard.css" type="text/css">

<body>
<a name="__top__"></a>
<table width=100% border=0 cellspacing=0>
  <tr>
    <td width=213>
      <a href="http://www.planetquake.com/quark"><img src="quarkicon.png" width=213 height=90 border=0 alt="Go to QuArK Web Site"></a>
    </td>
    <td width=70% align=center>
      <div class="topheadline">QuArK's Model Structure</div>
      <div class="sm">Updated&nbsp;01 Jan 2007</div>
    </td>
    <td width=30% valign=bottom nowrap>
      Upper&nbsp;levels:<br>-&nbsp;<a href="index.html">QuArK&nbsp;Information&nbsp;Base</a><br>-&nbsp;<a href="intro.html">1.&nbsp;Introduction&nbsp;to&nbsp;QuArK</a><br>-&nbsp;<a href="intro.modeleditor.html">1.5.&nbsp;Model-editor&nbsp;in&nbsp;QuArK</a><br>
    </td>
  </tr>
</table>
<table width=100% border=0 cellspacing=0>
  <tr class="headline">
    <td width=99%>
      <p class="headline">&nbsp;1.5.1.&nbsp;QuArK's Model Structure</p>
    </td>
    <td width=1% align=right nowrap>
      &nbsp;[&nbsp;<span class="navenable"><a href="intro.modeleditor.html">Prev</a></span>&nbsp;-&nbsp;<span class="navenable"><a href="intro.modeleditor.html">Up</a></span>&nbsp;-&nbsp;<span class="navenable"><a href="intro.modeleditor.menu.html">Next</a></span>&nbsp;]&nbsp;
    </td>
  </tr>
</table>
<table border=0 width=100% cellspacing=10><tr><td><p>This section covers more of the technical part, in detail, of QuArK's Model Structure for programming
purposes and is very important to understand if you plan to do any code writing for the Model Editor.
Occasionally references will be made to the Model Editor's Python code located in the quarkpy and
plugins folders as well as areas in the <a href="src.quarkx.html">'QuarkX'</a> section of these Infobase docs.
</p>
</td></tr></table>
<br>

<table width=100% border=0 cellspacing=0>
  <tr class="headline">
    <td width=100%>
      <p class="subheadline">&nbsp;Index</p>
    </td>
  </tr>
</table>
<ul class="index">
  <li>- <a href="#components">Components of a Model</a>&nbsp;<span class="added">(31 Dec 2006)</span>
  <li>- <a href="#mesh">The Model's Mesh(s)</a>&nbsp;<span class="added">(01 Jan 2007)</span>
</ul>
<br>


<a name="components"></a>
  <table width=100% border=0 cellspacing=0>
    <tr class="headline">
      <td>
        <p class="item">&nbsp;Components of a Model</p>
      </td>
      <td align=right>
        <font size=-2>cdunde&nbsp;-&nbsp;31 Dec 2006</font>
      </td>
      <td width=1% align=right nowrap>
        &nbsp;&nbsp;[&nbsp;<a href="#__top__">Top</a>&nbsp;]&nbsp;
      </td>
    </tr>
  </table>
  <table border=0 width=100% cellspacing=10><tr><td>
<p>A model is a single <b>QuArK Internal Object</b> that can consist of a single or mutipal <b>components</b>.
The elements that make up a model are stored as &quot;<a href="glossary.html#k">key</a><b>:</b><a href="glossary.html#v">value</a>&quot; pairs of the QuArK Internal Object,
where there is a <a href="glossary.html#k">key</a> name and a <a href="glossary.html#v">value</a> that goes along with that <a href="glossary.html#k">key</a> name.
</p><p>Also, each of the &quot;key names&quot; CAN BE given a specific <a href="glossary.html#t">type</a> to distinguish what kind of element it is.
So an example of a <a href="glossary.html#k">key</a>, its <a href="glossary.html#t">type</a> and its related <a href="glossary.html#v">value</a> would look like this:
<div class="doccode"><pre>{'Skins:sg': &lt;QuArK Internal object at 0x01390F78&gt;}</pre></div>
</p><p>The <a href="glossary.html#k">key</a> name is Skins, its <a href="glossary.html#t">type</a> sg (skin group) and its <a href="glossary.html#v">value</a> is another QuArK Internal Object (the skin group).
This method of using &quot;<a href="glossary.html#k">key</a><b>:</b><a href="glossary.html#v">value</a>&quot; pairs runs all the way through as a model's <b>component(s)</b> elements are broken down.
</p><p>A list of the different &quot;type&quot;s of &quot;key&quot;s is shown in the code example below, <a href="glossary.html#d">displayed in blue</a>.<br>
This code is located in the <a href="glossary.html#q">quarkpy\mdlmgr.py</a> file's <a href="glossary.html#d">def selchange(self)<b>:</b></a> section
of the <a href="glossary.html#c">class ModelLayout(BaseLayout)<b>:</b></a> class<br>
This code structures these items in the same way they are displayed in the QuArK Model Editor Tree-view:
</p><p><img border=0 align=right src="intro.modeleditor.model.components1.png">
</p><p><a href="glossary.html#f">fs = self.explorer.uniquesel</a><br>(what is selected at the moment.)<br>
<a href="glossary.html#i">if fs is not None:</a><br>(to test that something IS selected.)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="glossary.html#f">fs.type == ':mg':</a><br>(<b>misc. group</b> [contains the <b>:bone</b> items shown within it])<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="glossary.html#f">fs.type == ':mc':</a><br>(<b>model component</b> [contains the <b>element groups</b> shown within it])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="glossary.html#s">self.selectcomponent(fs)</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="glossary.html#f">fs.type == ':sg':</a><br>(<b>skin group</b> [contains the individual skins shown within it])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="glossary.html#s">self.selectcgroup(fs)</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="glossary.html#e">elif fs.type == ':fg':</a><br>(<b>frame group</b> [contains the individual frames shown within it])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="glossary.html#s">self.selectcgroup(fs)</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="glossary.html#f">fs.type == ':bg':</a><br>(<b>bone group</b> [contains the individual bones, if they exist])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="glossary.html#s">self.selectcgroup(fs)</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="glossary.html#f">fs.type == '.pcx':</a><br>(<b>skin</b> [texture file])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="glossary.html#s">self.selectskin(fs)</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="glossary.html#f">fs.type == '.jpg':</a><br>(<b>skin</b> [texture file])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="glossary.html#s">self.selectskin(fs)</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="glossary.html#f">fs.type == '.tga':</a><br>(<b>skin</b> [texture file])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="glossary.html#s">self.selectskin(fs)</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="glossary.html#f">fs.type == ':mf':</a><br>(<b>frame group</b> [for animation])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="glossary.html#s">self.selectframe(fs)</a><br>
</p><p>the rest of this models <a href="glossary.html#t">types</a>, not being displayed in the tree-view are:
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="glossary.html#f">fs.type == ':sdo':</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(not sure what this stands for)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="glossary.html#"">":tag"</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(TagType())<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="glossary.html#"">":bone"</a>&nbsp;&nbsp;&nbsp;&nbsp;(BoneType())<br>
</p><p>The key name can be any arbitrary name, even the short path and name of the model skin file itself, as shown below:
<div class="doccode"><pre>{'models/characters/autopsy_d.tga': &lt;QuArK Internal object at 0x01390F78&gt;}</pre></div>
</p><p>The <b>QuArK Internal object</b>, in the above example, is the actual autopsy_d.tga <b>skin</b> texture image file
that is stored in memory and can be called upon to display in one of the editor's views by using its <a href="glossary.html#k">key</a> name
OR by giving the program functiion the related <b>QuArK Internal object</b> by using its <a href="glossary.html#k">key</a> name.
That all depends on what a particular program function needs, just the path and name or the actual image file, to perform its task.
</p>
  </td></tr></table>
  <br>

<a name="mesh"></a>
  <table width=100% border=0 cellspacing=0>
    <tr class="headline">
      <td>
        <p class="item">&nbsp;The Model's Mesh(s)</p>
      </td>
      <td align=right>
        <font size=-2>cdunde&nbsp;-&nbsp;01 Jan 2007</font>
      </td>
      <td width=1% align=right nowrap>
        &nbsp;&nbsp;[&nbsp;<a href="#__top__">Top</a>&nbsp;]&nbsp;
      </td>
    </tr>
  </table>
  <table border=0 width=100% cellspacing=10><tr><td>
<p>A model is constructed from a mesh, which is a list of triangles grouped together to create its shape.
The model can be a single mesh or it can consist of a number of meshes. In QuArK we call these meshes components.
And therefore, each component of a model has its own group of triangles which are know as a component's
<a href="src.quarkx.html#objectsmodeleditor">Tris Specific</a> as stated in the
<a href="src.quarkx.html#objectsmodeleditor">Quarkx Model Editor section</a> of these Infobase docs.
Tris is an abbreviation for triangles.
</p><p>Even though you can think of a component's Tris as a very complex poly, like those used in the QuArK Map Editor,
and each triangle as a face of that poly, these triangles are handled differently in the Model Editor.
However, like a poly face, each triangle has three vertexes arranged in a specific order which tells which side of that triangle face is facing outwards.
</p><p>Instead of a set of 3 <a href="glossary.html#t">tuples</a> of 3 values each (x, y and z) that give the 3 points of a triangle,
the triangle of a component gives these values for its 3 <a href="glossary.html#t">tuples</a>:<br>
</p><p>&nbsp;&nbsp;<i>1st item:</i>&nbsp; The triangle’s <a href="glossary.html#v">vertexnumber</a>, also known as its <a href="glossary.html#i">index number</a>, which can be used to call a specific triangle.<br>
&nbsp;&nbsp;<i>2nd item:</i>&nbsp; The <a href="glossary.html#s">skin_s</a> value for the position of the models skin texture on the triangle.<br>
&nbsp;&nbsp;<i>3rd item:</i>&nbsp; The <a href="glossary.html#s">skin_t</a> value for the 2nd position of the models skin texture on the triangle.
</p><p>This can be misleading if you do not understand the differences between the 3 <a href="glossary.html#t">tuples</a> of a
standard poly triangle and the triangle of a models component mesh or Tris. This is also discribed in the
<a href="src.quarkx.html#objectsmodeleditor">Quarkx Model Editor section</a> of these Infobase docs.
</p><p>The actual 3 point positions of a components triangle are given by calling the triangle's <a href="glossary.html#v">vertexnumber</a>
to retrieve its <a href="glossary.html#v">vertices</a> list which is a set of 3 <a href="glossary.html#t">tuples</a> of 3 values each (x, y and z)
that give the 3 points for that triangle. Again, this is briefly covered in the
<a href="src.quarkx.html#objectsmodeleditor">Quarkx Model Editor section</a> of these Infobase docs.
</p><p>I realize all of this can be confusing, so let me give you an example using some actual code that is
located in two related sections of the <a href="glossary.html#q">quarkpy\mdlhandles.py</a> file that create and draw the handle for each vertex.
</p>
<p>In this first section of code we start off by setting up a list that will be used to store all of the handles (line 1), as they are created and drawn.<br>
Next we can see how the <a href="glossary.html#c">component.triangles</a> is called to retrieve its Tris list and their <a href="glossary.html#t">tuple</a> values (line 2).<br>
Now we can call for the <a href="glossary.html#v">vertices</a> of each triangle, in a loop function, by its index <a href="glossary.html#v">vertexnumber</a> (lines 3 and 4).<br>
Once we get one vertices of a triangle, we then go into another loop to retrieve each of the 3 vertex point values (x, y and z)<br>
for one of the 3 points of that triangel (lines 5 and 6).<br>
We then do two things as one, pass the data to the second section of code, which is covered down,<br>
and <a href="glossary.html#a">append</a> (add) the returned handle to our <a href="glossary.html#h">h</a> handle list (line 7). Which in this case is for the Skin-view handles.
</p><p><a href="glossary.html#(">(line 1) &nbsp;&nbsp;&nbsp;h = [ ]</a><br>
<a href="glossary.html#(">(line 2) &nbsp;&nbsp;&nbsp;tris = component.triangles</a><br>
<a href="glossary.html#(">(line 3) &nbsp;&nbsp;&nbsp;for i in range(len(tris)):</a><br>
<a href="glossary.html#(">(line 4) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tri = tris[i]</a><br>
<a href="glossary.html#(">(line 5) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for j in range(len(tri)):</a><br>
<a href="glossary.html#(">(line 6) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vtx = tri[j]</a><br>
<a href="glossary.html#(">(line 7) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h.append(SkinHandle(quarkx.vect(vtx[1]-int(texWidth*.5), vtx[2]-int(texHeight*.5), 0), i, j, component, texWidth, texHeight, tri))</a>
</p><p>A print statement you can use to print it to the QuArK console is this:
<div class="doccode"><pre>print &quot;SkinHandle &quot;,quarkx.vect(vtx[1], vtx[2], 0), i, j</pre></div>
placed just under the code line above. The console will display  3 vertexes for each face like this:
</p><p>SkinHandle &nbsp;&nbsp;40 46 0 74 0<br>
SkinHandle &nbsp;&nbsp;59 48 0 74 1<br>
SkinHandle &nbsp;&nbsp;55 34 0 74 2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;|<br>
&nbsp;&nbsp;2D pix. pos.&nbsp;&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;&nbsp;z&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;|<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;|<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;face index number&nbsp;&nbsp;&nbsp;|<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertex order in a clockwise direction
</p><p>One final thing you might want to notice is the very last item, or argument, that we pass to the <a href="glossary.html#c">class SkinHandle</a> code section is <a href="glossary.html#t">the list of triangle vertices</a> or <a href="glossary.html#t">tri</a> itself.<br>
This we will use in that code to do one other function, that of drawing the <a href="glossary.html#m">movement</a> lines of a vertex handle, as a guide, while it is being dragged to change the position of the vertex and skin appearance on the model.
</p><p>Now for the <a href="glossary.html#c">class SkinHandle</a> part of the code, located above this code, in the same <a href="glossary.html#q">quarkpy\mdlhandles.py</a> file, but I won't go through all of it here, for simplicity.
</p><p>The <a href="glossary.html#c">class SkinHandle</a> section consist of two main parts, the <a href="glossary.html#d">def draw</a> and the <a href="glossary.html#d">def drag</a> sections, the first of the two being simpler and more direct to the point I am making to the code. So we will take
a look at the <a href="glossary.html#d">def draw</a> section in part. One basic point about classes here is that we do not pass all of the above <a href="glossary.html#a">arguments</a> directly to the <a href="glossary.html#d">def drag</a> section itself, but to the class that it lies within.
From the base class we can then pass is on to the actual <a href="glossary.html#d">def draw</a> section by attaching the word <a href="glossary.html#s">self</a>, meaning the class itself, and because the <a href="glossary.html#d">def draw</a> is within that class we can then use <a href="glossary.html#s">self.triangle</a>
and use that arguments data in the draw section. Note how we also changed the arguments variable name from just <a href="glossary.html#t">tri</a> to <a href="glossary.html#t">triangle</a> to make it more clear in the code as to what that item really represents (or actually contains).
</p><p>Now , in the <a href="glossary.html#d">def draw</a> section of code, we will just look at a few lines intermittently to see how it uses this particular argument.
</p><p>First we obtain it from the base class arguments that it receives and redefine it with a new name (line 1).<br>
Next, because it already is <a href="glossary.html#t">the list of triangle vertices</a> that we need, we simply use a loop to go through that list, one vertex at a time, and get the data for each vertex of the triangle that we need to draw the vertex dragging guide lines (line 2).<br>
</p><p>This next part is a little bit tricky to understand, so bear with me.<br>
In the <a href="glossary.html#d">def draw</a> section, it receives an argument <a href="glossary.html#s">self</a> also, which in the <a href="glossary.html#d">def draw</a> case, <b>IS</b> the vertex handle that we are dragging, and also position 0 of the triangle.<br>
It is also located in <a href="glossary.html#t">the list of triangle vertices</a> along with the triangles two other vertex positions, 1 and 2. Items like this start with a count of 0 instead of 1 when it comes to programming. So the two other vertexes represent the <a href="glossary.html#s">stationary</a>
vertexes of the triangle that are <b>NOT</b> being dragged, but are needed to draw the lines from the one that is being dragged, and to give us our guide line fixed positions for drawing in a lime green color so they are easily seen in the Skin-view as shown in the screen shot.
</p><p>So with that out of the way, we pull those stationary vertexes out of the list, which is a <a href="glossary.html#t">tuple</a> of 3 vertexes (pos 0, 1 and 2), and define each vertex as a <a href="glossary.html#v">vector</a> called <a href="glossary.html#f">fixedvertex</a> (line 10), skipping the first one (lines 3-6) because that is our <a href="glossary.html#s">self</a> drag handle.
Which we already have and will be drawing our guide lines from.
</p><p>Something else you might have noticed here is that we <b>do not</b> use position 0 and 1 (x and y) here as you might think, but positions 1 and 2 (y and z) instead.<br>
<a href="glossary.html#v">vertex[1]...vertex[2]</a><br>
Don't ask me why, it's just the way the <a href="glossary.html#q">quarkx.vect</a> function works.
</p><p>Once we have defined our <a href="glossary.html#v">vector</a> it also becomes a <a href="glossary.html#t">tuple</a>, so now we need to pull out that vertex's positions for X , Y and Z (line 11).<br>
Because these positions are actually pixels on a flat 2D screen (your monitor), with 0,0 being at the upper left hand corner of the Skin-view, the value for Z is not needed.<br>
So we just ignore that one and use the X and Y positions for the fixed end of a line and the X and Y positions of our vertex handle for the other end( line 12).
</p><p>Remember, this is done for each line that is drawn as the handle vertex and its triangle are passes to the <a href="glossary.html#c">class  SkinHandle</a> from the first section of code.
looking at the actual and complete code in the file will fill in the gaps and help answer any questions of other items shown below.
</p><p><a href="glossary.html#(">(line 1) &nbsp;&nbsp;&nbsp;triangle = self.triangle</a>
</p><p>(skipping a few lines of code)
</p><p><a href="glossary.html#(">(line 2) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for vertex in triangle:</a><br>
<a href="glossary.html#(">(line 3) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if self.ver_index == 0:</a><br>
<a href="glossary.html#(">(line 4) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if  count != 0: break</a><br>
<a href="glossary.html#(">(line 5) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count = count + 1</a><br>
<a href="glossary.html#(">(line 6) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pass</a><br>
<a href="glossary.html#(">(line 7) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:</a><br>
<a href="glossary.html#(">(line 8) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if  count > 2: break</a><br>
<a href="glossary.html#(">(line 9) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count = count + 1</a><br>
<a href="glossary.html#(">(line 10)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fixedvertex = quarkx.vect(vertex[1]-int(texWidth*.5), vertex[2]-int(texHeight*.5), 0)</a><br>
<a href="glossary.html#(">(line 11)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fixedX, fixedY,fixedZ = view.proj(fixedvertex).tuple</a><br>
<a href="glossary.html#(">(line 12)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cv.line(int(pv2[0]), int(pv2[1]), int(fixedX), int(fixedY))</a><br>
</p><p>And in the screen shot below you can see these vertex handles for the component <a href="glossary.html#d">deadeye</a> Tris as they
are displayed in both the Model Editors views and its Skin-view page. Just remember though, the handles in the
Model Editor views, which move the components mesh for the models shape, are NOT the same handles that are shown on the Skin-view page,
which move the <a href="glossary.html#u">unwrapped</a> components mesh for skinning purposes. So one handle type will NOT effect the other.
But both are created and drawn in the same way, they just wind up in different <a href="glossary.html#h">handle lists</a>.
</p><p><table width=100% cellspacing=0>
<tr><td valign=top align=middle>
<img border=0 align=middle src="intro.modeleditor.model.mesh1.png">
</td></tr>
</table>
</p>
  </td></tr></table>
  <br>

<br>

<table width=100% border=0 cellspacing=0>
  <tr class="headline">
    <td width=99% align=middle>
      <p class="sm">
        GNU General Public License by The QuArK (Quake Army Knife) Community - <a href="http://www.planetquake.com/quark">http://www.planetquake.com/quark</a>
      </p>
    </td>
    <td width=1% align=right nowrap>
      &nbsp;[&nbsp;<span class="navenable"><a href="intro.modeleditor.html">Prev</a></span>&nbsp;-&nbsp;<a href="#__top__">Top</a>&nbsp;-&nbsp;<span class="navenable"><a href="intro.modeleditor.menu.html">Next</a></span>&nbsp;]&nbsp;
    </td>
  </tr>
</table>
</body>
</html>